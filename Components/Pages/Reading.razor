@page "/Reading/{ComicBookId:int}/{GroupId:int}"
@layout ReadingLayout
@implements IJsKeyEventListener
@implements IJsScrollEventListener
@implements IDisposable
@using Zine.App.Domain.ComicBook
@using Zine.App.Domain.ComicBook.Reading
@using Zine.App.Helpers.Canvas
@using Zine.App.Helpers.JsHelpers
@using Zine.Components.Layout

@inject NavigationManager NavigationManager;
@inject IComicBookService ComicBookService
@inject IJSRuntime JsRuntime;

<script src="js/Reading.js"></script>

<MudContainer Class="py-5 h-[calc(100vh-64px)]">
	<div class="relative">
		<MudDrawer Open="PageExplorerOpen" Variant="DrawerVariant.Persistent" ClipMode="DrawerClipMode.Always">
			<div>
				@foreach (var (pageIndex, image) in _readingPageHandler.Images.Select((image, index) => (index, image)))
				{
					<div id="image-@pageIndex" class="mb-2 mx-2 first:mt-2 last:mb-2 cursor-pointer @(_readingPageHandler.CurrentPageIndex == pageIndex ? "outline outline-offset-1 outline-primary" : "outline-0")">
						<MudImage
							Src="@image"
							@onclick="() => GoToPage(pageIndex)" />
					</div>
				}
			</div>
		</MudDrawer>
	</div>

	<main class="h-full flex flex-col gap-3">

		<div class="w-full h-10 bg-dark rounded-lg py-2 px-4 flex justify-end items-center leading-8">
			<MudIcon Icon="@Icons.Material.Filled.ZoomIn" class="toolbar-icon" @onclick="_readingPageHandler.ZoomIn"/>
			<MudIcon Icon="@Icons.Material.Filled.ZoomOut" class="toolbar-icon" @onclick="_readingPageHandler.ZoomOut"/>

			<div class="ml-2 w-10 text-end">
				@_readingPageHandler.ZoomScale%
			</div>
		</div>

		<div class="w-full h-full flex justify-center items-center overflow-hidden relative">
			<canvas id="CurrentPage" class="w-full h-full block"></canvas>
		</div>

		<div class="h-14 w-full flex flex-row items-center justify-center gap-3 select-none">

			<MudIcon Class="cursor-pointer" Icon="@Icons.Material.Filled.KeyboardDoubleArrowLeft" @onclick="FirstPage" />
			<MudIcon Class="cursor-pointer" Icon="@Icons.Material.Filled.KeyboardArrowLeft" @onclick="PrevPage" />

			<div>@(_readingPageHandler.CurrentPageIndex + 1) / @_readingPageHandler.ComicBook.Information.NumberOfPages</div>

			<MudIcon Class="cursor-pointer" Icon="@Icons.Material.Filled.KeyboardArrowRight" @onclick="NextPage" />
			<MudIcon Class="cursor-pointer" Icon="@Icons.Material.Filled.KeyboardDoubleArrowRight" @onclick="LastPage" />

		</div>
	</main>

</MudContainer>

@code {

	[Parameter]
	public int ComicBookId { get; set; }

	[Parameter]
	public int GroupId { get; set; }


	const bool PageExplorerOpen = true;

	DotNetObjectReference<Reading>? _componentRef;

	ReadingPageHandler _readingPageHandler = null!;

	CanvasHandler _canvasHandler = null!;


	void InitReadingPageHandler(IComicBookService comicBookService, CanvasHandler canvasHandler)
	{
		_readingPageHandler = new ReadingPageHandler(
			NavigationManager,
			comicBookService,
			canvasHandler,
			GroupId,
			ComicBookId);
	}

	void InitCanvasHandler()
	{
		_canvasHandler = new CanvasHandler(JsRuntime, "CurrentPage");
	}

	[JSInvokable]
	public void JsOnKeyDown(KeyboardEventArgs eventArgs)
	{
		switch (eventArgs.Key)
		{
			case "ArrowUp":
			case "ArrowLeft":
				PrevPage();
				break;
			case "ArrowRight":
			case "ArrowDown":
				NextPage();
				break;
		}
	}

	[JSInvokable]
	public async Task ElementScrolledAsync(ScrollEvent scrollEvent)
	{

		switch (scrollEvent.Modifier)
		{
			case KeyModifier.None:
				HandleScrollPageChange(scrollEvent.Direction);
				break;
			case KeyModifier.Ctrl:
				await HandleScrollZoomChange(scrollEvent.Direction);
				break;
			case KeyModifier.Alt:
			case KeyModifier.Shift:
			default:
				break;
		}
	}

	void HandleScrollPageChange(ScrollDirection direction)
	{
		switch (direction)
		{
			case ScrollDirection.Down:
				NextPage();
				break;
			case ScrollDirection.Up:
				PrevPage();
				break;
			default:
				throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
		}
	}

	async Task HandleScrollZoomChange(ScrollDirection direction)
	{
		switch (direction)
		{
			case ScrollDirection.Down:
				await _readingPageHandler.ZoomOut();
				break;
			case ScrollDirection.Up:
				await _readingPageHandler.ZoomIn();
				break;
			default:
				throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
		}

		StateHasChanged();
	}

	void GoToPage(int pageIndex)
	{
		_readingPageHandler.GoToPage(pageIndex);
		StateHasChanged();
		JsRuntime.InvokeVoidAsync("scrollElementIntoView", "image-" + _readingPageHandler.CurrentPageIndex);
	}

	void FirstPage()
	{
		_readingPageHandler.GoToFirstPage();
		StateHasChanged();
		JsRuntime.InvokeVoidAsync("scrollElementIntoView", "image-" + _readingPageHandler.CurrentPageIndex);
	}

	void PrevPage()
	{
		_readingPageHandler.PrevPage();
		StateHasChanged();
		JsRuntime.InvokeVoidAsync("scrollElementIntoView", "image-" + _readingPageHandler.CurrentPageIndex);
	}

	void LastPage()
	{
		_readingPageHandler.GoToLastPage();
		StateHasChanged();
		JsRuntime.InvokeVoidAsync("scrollElementIntoView", "image-" + _readingPageHandler.CurrentPageIndex);
	}

	void NextPage()
	{
		_readingPageHandler.NextPage();
		StateHasChanged();
		JsRuntime.InvokeVoidAsync("scrollElementIntoView", "image-" + _readingPageHandler.CurrentPageIndex);
	}

	protected override void OnInitialized()
	{
		base.OnInitialized();

		InitCanvasHandler();
		InitReadingPageHandler(ComicBookService, _canvasHandler);

	}


	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			_componentRef = DotNetObjectReference.Create(this);

			_readingPageHandler.RefreshCanvasImage();

			await JsRuntime.InvokeVoidAsync("JsFunctions.registerKeyDownEventListener", _componentRef);
			await JsRuntime.InvokeVoidAsync("JsFunctions.registerOnScrollListener", "CurrentPage", _componentRef, HandlerType.Async);
		}
	}

	public void Dispose()
	{
		_componentRef?.Dispose();
	}


}
